Wrote profile results to 'main.py.lprof'
Timer unit: 1e-06 s

Total time: 4.78779 s
File: /home/aaron/team_project/sh11-main/plotter/utils.py
Function: detrend_and_filter at line 120

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   120                                           @profile
   121                                           def detrend_and_filter(v: np.ndarray, fs: float | None, bandpass: bool = True) -> np.ndarray:
   122                                               '''
   123                                               Remove baseline drift or apply a 0.5–40 Hz bandpass filter.
   124                                           
   125                                               Args:
   126                                                   v (ndarray): Input voltage trace.
   127                                                   fs (float | None): Sampling rate in Hz.
   128                                                   bandpass (bool): If True, apply 0.5–40 Hz Butterworth bandpass.
   129                                           
   130                                               Returns:
   131                                                   ndarray: Filtered or detrended signal.
   132                                           
   133                                               Theory:
   134                                                   ECG signals typically contain frequencies between 0.5 and 40 Hz.
   135                                                   - Baseline drift (caused by breathing or electrode motion) occurs below ~0.5 Hz.
   136                                                   - High-frequency noise (e.g. muscle artifacts) appears above ~40 Hz.
   137                                           
   138                                                   When `bandpass` is True:
   139                                                       A 4th-order Butterworth bandpass is applied with corner frequencies
   140                                                       f_low = 0.5 Hz and f_high = 40 Hz. The normalized cutoffs are:
   141                                                           w_low  = f_low  / (fs / 2)
   142                                                           w_high = f_high / (fs / 2)
   143                                                       The Butterworth filter has a maximally flat passband response and is
   144                                                       implemented in second-order sections for numerical stability.
   145                                                       The signal is filtered forward and backward using `sosfiltfilt`,
   146                                                       producing zero-phase distortion.
   147                                           
   148                                                   When `bandpass` is False:
   149                                                       Baseline drift is removed by estimating the slow-varying component
   150                                                       using a rolling median window:
   151                                                           baseline[i] = median(v[i - w/2 : i + w/2])
   152                                                       where the window size w ~= 0.2 * fs (about 200 ms). This captures the
   153                                                       low-frequency baseline while preserving the shape of QRS complexes.
   154                                                       The detrended signal is:
   155                                                           v_detrended = v - baseline
   156                                               '''
   157         1      16807.8  16807.8      0.4      v = np.asarray(v, dtype=np.float32)
   158                                           
   159         1         11.8     11.8      0.0      win = int(max(3, round(0.2 * (fs or 250.0))))
   160         1          1.6      1.6      0.0      if win % 2 == 0:
   161         1          1.8      1.8      0.0          win += 1
   162         1          0.6      0.6      0.0      try:
   163         1          1.7      1.7      0.0          baseline = (
   164         3      21643.2   7214.4      0.5              pd.Series(v)
   165         1          0.8      0.8      0.0              .rolling(window=win, center=True, min_periods=1)
   166         1    4731014.9 4.73e+06     98.8              .median()
   167         1         28.8     28.8      0.0              .to_numpy()
   168         1          1.8      1.8      0.0              .astype(np.float32, copy=False)
   169                                                   )
   170         1      18277.5  18277.5      0.4          return v - baseline
   171                                               except Exception:
   172                                                   return v - np.float32(np.mean(v, dtype=np.float64))

Total time: 5.30326 s
File: /home/aaron/team_project/sh11-main/plotter/utils.py
Function: clean_with_noise at line 300

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   300                                           @profile
   301                                           def clean_with_noise(t: np.ndarray, y: np.ndarray, art_times: np.ndarray, fs: float | None) -> np.ndarray:
   302         1          2.5      2.5      0.0      if art_times.size == 0 or not fs or fs <= 0:
   303                                                   return y.copy()
   304                                           
   305         1      21566.7  21566.7      0.4      y_out = y.copy()
   306         1          2.5      2.5      0.0      n = y_out.size
   307                                           
   308         1          0.8      0.8      0.0      base_window_ms = 12
   309         1          0.7      0.7      0.0      extra_tail_ms = 10
   310         1          0.8      0.8      0.0      noise_strength = 0.25
   311         1          0.7      0.7      0.0      taper_ms = 8
   312         1          0.6      0.6      0.0      fit_neighbors = 45
   313                                           
   314         1          4.7      4.7      0.0      win_half = int(base_window_ms * fs / 1000)
   315         1          0.9      0.9      0.0      tail_extra = int(extra_tail_ms * fs / 1000)
   316         1          0.5      0.5      0.0      feather = int(taper_ms * fs / 1000)
   317         1          0.9      0.9      0.0      k_neighbor = int(fit_neighbors * fs / 1000)
   318                                           
   319         1        231.7    231.7      0.0      rng = np.random.default_rng(12345)
   320                                           
   321                                               # Precompute derivative once
   322         1      72922.0  72922.0      1.4      dv = np.diff(y_out, prepend=y_out[0])
   323                                           
   324                                               # ---- 1) Precompute local stats with uniform filter (O(N)) ----
   325         1          4.2      4.2      0.0      win_loc = max(3, 2 * k_neighbor)  # ensure odd-ish, non-zero
   326                                           
   327                                               # local mean of y and dv
   328         1     289989.6 289989.6      5.5      mean_y = uniform_filter1d(y_out.astype(np.float64), size=win_loc, mode="nearest")
   329         1     284453.6 284453.6      5.4      mean_dv = uniform_filter1d(dv.astype(np.float64), size=win_loc, mode="nearest")
   330                                           
   331                                               # local mean of squares for std
   332         1     300082.6 300082.6      5.7      mean_y2 = uniform_filter1d((y_out**2).astype(np.float64), size=win_loc, mode="nearest")
   333         1     301406.4 301406.4      5.7      mean_dv2 = uniform_filter1d((dv**2).astype(np.float64), size=win_loc, mode="nearest")
   334                                           
   335         1     137434.6 137434.6      2.6      std_y = np.sqrt(np.maximum(mean_y2 - mean_y**2, 0.0)) + 1e-6
   336         1     138435.7 138435.7      2.6      std_dv = np.sqrt(np.maximum(mean_dv2 - mean_dv**2, 0.0)) + 1e-6
   337                                           
   338                                               # ---- 2) Cache tapers by length to avoid repeated linspace/cos ----
   339         1          2.0      2.0      0.0      taper_cache: dict[int, np.ndarray] = {}
   340                                           
   341         1          3.3      3.3      0.0      def get_taper(L: int) -> np.ndarray:
   342                                                   """Cosine taper of length L (0..1..0)."""
   343                                                   # Use full length L; inside we may use only the first/last feather samples.
   344                                                   if L not in taper_cache:
   345                                                       if L <= 1:
   346                                                           taper_cache[L] = np.ones(L, dtype=float)
   347                                                       else:
   348                                                           # 0..pi for left, pi..0 for right is symmetric; here we precompute 0..pi
   349                                                           x = np.linspace(0.0, np.pi, L)
   350                                                           taper_cache[L] = 0.5 * (1.0 - np.cos(x))
   351                                                   return taper_cache[L]
   352                                           
   353                                               # art_times is assumed sorted; t is sorted
   354     31593      12536.2      0.4      0.2      for art in art_times:
   355     31592     842657.6     26.7     15.9          j = int(np.clip(np.searchsorted(t, art), 0, n - 1))
   356                                           
   357     31592       9044.8      0.3      0.2          s = j - win_half
   358     31592       7956.7      0.3      0.2          e = j + win_half
   359                                           
   360                                                   # Use precomputed local stats
   361     31592      20851.2      0.7      0.4          local_mean = float(mean_y[j])
   362     31592      13343.5      0.4      0.3          local_std = float(std_y[j])
   363     31592      13634.9      0.4      0.3          dv_std = float(std_dv[j])
   364                                           
   365     31592       9255.4      0.3      0.2          amp_thr = 2.5 * local_std
   366     31592       7110.1      0.2      0.1          dv_thr  = 2.5 * dv_std
   367                                           
   368                                                   # extend left
   369     31660       8518.2      0.3      0.2          while s > 0:
   370     31660      36059.5      1.1      0.7              if (abs(y_out[s] - local_mean) > amp_thr) or (abs(dv[s]) > dv_thr):
   371        68         21.9      0.3      0.0                  s -= 1
   372                                                       else:
   373     31592       6938.7      0.2      0.1                  break
   374                                           
   375                                                   # extend right
   376     31656       9551.6      0.3      0.2          while e < n - 1:
   377     31656      23154.4      0.7      0.4              if (abs(y_out[e] - local_mean) > amp_thr) or (abs(dv[e]) > dv_thr):
   378        64         18.6      0.3      0.0                  e += 1
   379                                                       else:
   380     31592       6371.3      0.2      0.1                  break
   381                                           
   382     31592      15104.9      0.5      0.3          s = max(0, s - tail_extra)
   383     31592      12979.5      0.4      0.2          e = min(n, e + tail_extra)
   384                                           
   385     31592       9097.8      0.3      0.2          if e - s < 3:
   386                                                       continue
   387                                           
   388                                                   # Local trend window
   389     31592      11349.6      0.4      0.2          left_start = max(0, s - k_neighbor)
   390     31592      10516.3      0.3      0.2          right_end  = min(n, e + k_neighbor)
   391                                           
   392     31592      12324.4      0.4      0.2          x_fit = t[left_start:right_end]
   393     31592       8786.6      0.3      0.2          y_fit = y_out[left_start:right_end]
   394                                           
   395                                                   # Spline trend (still accurate, but costly)
   396     31592       5531.9      0.2      0.1          try:
   397     31592    1648709.4     52.2     31.1              spline = UnivariateSpline(x_fit, y_fit, s=len(x_fit) * 0.002)
   398     31592     424193.3     13.4      8.0              trend = spline(t[s:e])
   399                                                   except Exception:
   400                                                       # fallback: linear
   401                                                       trend = np.linspace(y_out[s], y_out[e-1], e - s)
   402                                           
   403     31592       9042.8      0.3      0.2          sigma = noise_strength * local_std
   404     31592     142383.6      4.5      2.7          noise = rng.normal(0, sigma, e - s)
   405                                           
   406     31592      31480.6      1.0      0.6          replacement = trend + noise
   407                                           
   408                                                   # Cosine taper blending
   409     31592       7205.3      0.2      0.1          L = e - s
   410     31592     148295.2      4.7      2.8          w = np.ones(L, dtype=float)
   411                                           
   412     31592       8856.8      0.3      0.2          if feather > 1:
   413     31592      14107.6      0.4      0.3              lf = min(feather, L)
   414     31592       5575.3      0.2      0.1              rf = lf  # same length for right side
   415     31592      29354.5      0.9      0.6              taper_full = get_taper(max(lf, rf))
   416                                           
   417     31592      35467.6      1.1      0.7              w[:lf] = taper_full[:lf]       # rising
   418     31592      31569.3      1.0      0.6              w[-rf:] = taper_full[:rf][::-1]  # falling
   419                                           
   420     31592      12466.6      0.4      0.2          seg = y_out[s:e]
   421     31592      95286.9      3.0      1.8          y_out[s:e] = (1.0 - w) * seg + w * replacement
   422                                           
   423         1          0.2      0.2      0.0      return y_out

Total time: 5.94788 s
File: /home/aaron/team_project/sh11-main/plotter/utils.py
Function: detect_fiducials at line 602

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   602                                           @profile
   603                                           def detect_fiducials(
   604                                               t: np.ndarray,
   605                                               v: np.ndarray,
   606                                               fs: float,
   607                                               art_times: np.ndarray | None = None,
   608                                           ) -> list[BeatFeatures]:
   609                                               """
   610                                               Detect fiducial points P, Q, R, S, and T for each heartbeat.
   611                                           
   612                                               Args:
   613                                                   t (ndarray): Time vector in seconds.
   614                                                   v (ndarray): ECG voltage trace (preferably detrended/filtered).
   615                                                   fs (float): Sampling frequency in Hz.
   616                                                   art_times (ndarray | None): Optional array of artifact times (s),
   617                                                       e.g. from `detect_artifacts`. P and T points that land too
   618                                                       close to these times are rejected.
   619                                           
   620                                               Returns:
   621                                                   list[BeatFeatures]: One BeatFeatures instance per detected beat,
   622                                                   containing indices/times of P, Q, R, S, and T when available.
   623                                               """
   624                                           
   625         1          2.7      2.7      0.0      qrs_half = int(0.06 * fs)          # +-60 ms for Q and S around R
   626         1          1.2      1.2      0.0      p_min = int(0.08 * fs)             # 80 ms
   627         1          0.7      0.7      0.0      p_max = int(0.25 * fs)             # 250 ms
   628         1          0.4      0.4      0.0      r_ref_span = int(0.02 * fs)        # refine R within +-20 ms
   629         1          0.5      0.5      0.0      t_margin_after_S = int(0.06 * fs)  # start T >=60 ms after S
   630         1          0.4      0.4      0.0      t_margin_before_Q = int(0.04 * fs) # end T <=40 ms before next Q
   631         1          0.7      0.7      0.0      t_last_start = int(0.12 * fs)      # fallback T window for last beat
   632         1          0.8      0.8      0.0      t_last_end = int(0.60 * fs)        # fallback T window for last beat
   633         1          1.1      1.1      0.0      noise_gap = int(0.01 * fs)         # 10 ms around artifact indices
   634                                           
   635                                               # artifact indices (for P/T rejection)
   636         1          0.4      0.4      0.0      art_idx_all: np.ndarray | None = None
   637         1          1.0      1.0      0.0      if art_times is not None and art_times.size > 0:
   638                                                   # sorted integer indices into t
   639         1       5888.5   5888.5      0.1          art_idx_all = np.searchsorted(t, art_times).astype(int, copy=False)
   640                                           
   641                                               # rough R-peak indices
   642         1    1390545.3 1.39e+06     23.4      r_idx_raw = detect_r_peaks(t, v, fs, art_times=art_times)
   643         1          0.4      0.4      0.0      beats: list[BeatFeatures] = []
   644                                           
   645                                               # refine R, then find Q, S, P
   646    100048      25311.7      0.3      0.4      for ri0 in r_idx_raw:
   647                                                   # refine R: snap to actual max of v in +-20 ms window
   648    100047      61913.9      0.6      1.0          left = max(0, ri0 - r_ref_span)
   649    100047      66142.0      0.7      1.1          right = min(t.size, ri0 + r_ref_span)
   650    100047      43356.9      0.4      0.7          seg = v[left:right]
   651    100047      24969.2      0.2      0.4          if seg.size > 0:
   652    100047     347013.0      3.5      5.8              ri = int(left + np.argmax(seg))
   653                                                   else:
   654                                                       ri = int(ri0)
   655                                           
   656    100047     236130.4      2.4      4.0          bf = BeatFeatures(r_time=float(t[ri]), r_idx=ri)
   657                                           
   658                                                   # Q: local min before R
   659    100047      38881.2      0.4      0.7          q_start = max(0, ri - qrs_half)
   660    100047      18368.1      0.2      0.3          q_end = ri
   661    100047      21774.2      0.2      0.4          if q_end > q_start:
   662    100047     419061.3      4.2      7.0              q_local = int(np.argmin(v[q_start:q_end]) + q_start)
   663    100047      27994.3      0.3      0.5              bf.q_idx = q_local
   664    100047      53911.8      0.5      0.9              bf.q_time = float(t[q_local])
   665                                           
   666                                                   # S: local min after R
   667    100047      18769.9      0.2      0.3          s_start = ri
   668    100047      48120.1      0.5      0.8          s_end = min(t.size, ri + qrs_half * 2)
   669    100047      22676.4      0.2      0.4          if s_end > s_start:
   670    100047     353137.4      3.5      5.9              s_local = int(np.argmin(v[s_start:s_end]) + s_start)
   671    100047      28011.8      0.3      0.5              bf.s_idx = s_local
   672    100047      52517.8      0.5      0.9              bf.s_time = float(t[s_local])
   673                                           
   674                                                   # P: small peak before QRS
   675    100047      36469.1      0.4      0.6          p_end = max(0, ri - p_min)
   676    100047      32593.8      0.3      0.5          p_start = max(0, ri - p_max)
   677    100047      22072.7      0.2      0.4          if p_end > p_start:
   678    100047      35828.1      0.4      0.6              p_seg = v[p_start:p_end]
   679    100047      24349.1      0.2      0.4              if p_seg.size > 0:
   680    100047     354961.4      3.5      6.0                  p_local = int(np.argmax(p_seg) + p_start)
   681                                           
   682                                                           # reject if P lands on or very near an artifact
   683    100047     579222.0      5.8      9.7                  if _is_near_artifact(p_local, art_idx_all, noise_gap):
   684      1426        308.3      0.2      0.0                      p_local = None
   685                                           
   686    100047      24022.3      0.2      0.4                  if p_local is not None:
   687     98621      26339.1      0.3      0.4                      bf.p_idx = p_local
   688     98621      51321.7      0.5      0.9                      bf.p_time = float(t[p_local])
   689                                           
   690    100047      37174.6      0.4      0.6          beats.append(bf)
   691                                           
   692                                               # second pass: find T BETWEEN S_i and Q_{i+1}
   693    100048      23734.1      0.2      0.4      for i, bf in enumerate(beats):
   694    100047      30367.9      0.3      0.5          if i < len(beats) - 1:
   695    100046      25247.3      0.3      0.4              next_b = beats[i + 1]
   696                                           
   697                                                       # choose S_i or fallback R_i
   698    100046      30815.9      0.3      0.5              s_idx = bf.s_idx if bf.s_idx is not None else bf.r_idx
   699                                                       # choose Q_{i+1} or fallback R_{i+1}
   700    100046      37327.9      0.4      0.6              q_next_idx = next_b.q_idx if next_b.q_idx is not None else next_b.r_idx
   701                                           
   702    100046      21052.4      0.2      0.4              t_start = s_idx + t_margin_after_S
   703    100046      21189.2      0.2      0.4              t_end = q_next_idx - t_margin_before_Q
   704                                                   else:
   705                                                       # last beat: simple window after R
   706         1          0.5      0.5      0.0              t_start = bf.r_idx + t_last_start
   707         1          0.6      0.6      0.0              t_end = min(t.size - 1, bf.r_idx + t_last_end)
   708                                           
   709    100047      19947.4      0.2      0.3          if t_end <= t_start:
   710                                                       continue
   711                                           
   712    100047      32262.6      0.3      0.5          t_start = max(0, t_start)
   713    100047      33112.4      0.3      0.6          t_end = min(t.size, t_end)
   714                                           
   715    100047      37669.3      0.4      0.6          seg = v[t_start:t_end]
   716    100047      25548.0      0.3      0.4          if seg.size == 0:
   717                                                       continue
   718                                           
   719                                                   # dominant peak in between-beats segment (handles inverted T with abs)
   720    100047     404660.6      4.0      6.8          t_rel = int(np.argmax(np.abs(seg)))
   721    100047      25525.5      0.3      0.4          t_local = t_start + t_rel
   722                                           
   723                                                   # reject T if on/near artifact
   724    100047     565257.5      5.6      9.5          if _is_near_artifact(t_local, art_idx_all, noise_gap):
   725      1298        295.3      0.2      0.0              continue
   726                                           
   727     98749      28152.7      0.3      0.5          bf.t_idx = t_local
   728     98749      56541.5      0.6      1.0          bf.t_time = float(t[t_local])
   729                                           
   730         1          0.2      0.2      0.0      return beats

